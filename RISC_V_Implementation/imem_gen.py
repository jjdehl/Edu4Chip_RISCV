# Python script to generate a SystemVerilog instruction memory file (imem32.sv)
# It reads RISC-V instructions from a .dump file and generates the memory file.

import re

# Parameters for the memory
INSTR_LENGTH = 32
MEM_DEPTH = 128

# Input and output file names
dump_file = "test_loop2.dump"  # Input .dump file
output_file = "imem32_loop2.sv"    # Output SystemVerilog file

# Function to parse instructions from the .dump file
def parse_dump_file(dump_file):
    """
    Parses a RISC-V .dump file to extract instructions in hexadecimal format.
    Returns a list of 32-bit instruction strings.
    """
    instructions = []
    with open(dump_file, "r") as f:
        for line in f:
            # Match lines with instruction addresses and hex values
            match = re.match(r"^\s*[0-9a-f]+:\s+([0-9a-f]{8})", line)
            if match:
                # Extract the 32-bit instruction in hexadecimal
                instructions.append(f"32'h{match.group(1)}")
    return instructions

# Parse the .dump file
instructions = parse_dump_file(dump_file)

# Generate the SystemVerilog file
with open(output_file, "w") as f:
    f.write("`timescale 1ns / 1ps\n")
    f.write("//////////////////////////////////////////////////////////////////////////////////\n")
    f.write("// Auto-generated instruction memory file\n")
    f.write("// Generated by imem_gen.py\n")
    f.write("//////////////////////////////////////////////////////////////////////////////////\n\n")
    f.write(f"module imem32(\n")
    f.write(f"    input  logic clk,\n")
    f.write(f"    input  logic rst,\n")
    f.write(f"    input  logic [{INSTR_LENGTH-1}:0] addr,\n")
    f.write(f"    output logic [{INSTR_LENGTH-1}:0] instr\n")
    f.write(f");\n\n")
    f.write(f"    logic [{INSTR_LENGTH-1}:0] instr_reg [{MEM_DEPTH-1}:0];\n\n")
    f.write(f"    always_ff @(posedge clk) begin\n")
    f.write(f"        if (rst) begin\n")
    f.write(f"            instr <= {{{INSTR_LENGTH}{{1'b0}}}};\n")
    f.write(f"        end else begin\n")
    f.write(f"            instr <= instr_reg[addr];\n")
    f.write(f"        end\n")
    f.write(f"    end\n\n")
    f.write(f"    initial begin\n")

    # Write the instructions to the memory
    for i in range(MEM_DEPTH):
        if i < len(instructions):
            f.write(f"        instr_reg[{i}] = {instructions[i]};\n")
        else:
            f.write(f"        instr_reg[{i}] = 32'h00000013; // NOP\n")

    f.write(f"    end\n")
    f.write(f"endmodule\n")

print(f"Instruction memory file '{output_file}' generated successfully!")